# MapReduce Framework

## **Overview**
This project is a custom implementation of a multi-threaded **MapReduce Framework** in C++. The framework processes input data using the MapReduce paradigm, with distinct **Map**, **Shuffle**, and **Reduce** phases. It is designed to work efficiently with multithreading and provides synchronization primitives to ensure thread safety. The implementation was developed and tested on **Linux**, leveraging POSIX threading libraries.

---

## **Features**
- Supports **multi-threaded execution** with a user-defined number of threads.
- Implements key phases:
    1. **Map**: Processes input key-value pairs to generate intermediate key-value pairs.
    2. **Shuffle**: Groups intermediate pairs by keys.
    3. **Reduce**: Processes grouped intermediate pairs to produce final output.
- Provides robust synchronization using:
    - Mutexes.
    - Atomic counters.
    - Custom **Barrier** class for thread synchronization.
- Ensures safety and correctness with error handling and dynamic memory management.
- Fully tested on **Linux** environments.

---

## **File Structure**

| **File**                 | **Description**                                                                                                                                       |
|--------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|
| `MapReduceFramework.h`   | Defines the public interface for the framework, including `startMapReduceJob`, `waitForJob`, `getJobState`, and `closeJobHandle`.                     |
| `MapReduceFramework.cpp` | Implements the framework logic, including thread management, synchronization, and the MapReduce workflow.                                            |
| `MapReduceClient.h`      | Defines the `MapReduceClient` interface that users must implement to define their custom `map` and `reduce` functions.                               |
| `SampleClient.cpp`       | A sample implementation of the `MapReduceClient` for counting character occurrences in strings.                                                      |
| `Barrier.h`, `Barrier.cpp` | A reusable barrier implementation for thread synchronization during Shuffle and Reduce phase transitions.                                          |
| `Makefile`               | Defines the build rules for compiling the project and running the example.                                                                           |

---

## **Setup and Compilation**

### **Dependencies**
- A C++11-compatible compiler.
- `pthread` library (POSIX threads).
- **Linux environment**.

### **Build Instructions**
1. Open a terminal and navigate to the project directory.
2. Run the following command to build the project:
   ```bash
   make
   ```
3. This will generate an executable named `SampleClient`.

---

## **Usage**

### **Input and Output Format**
1. **Input**:
    - A vector of key-value pairs (`InputVec`) where keys are `K1*` and values are `V1*`.
    - Example:
      ```cpp
      InputVec inputVec = { {nullptr, new VString("example string")} };
      ```
2. **Output**:
    - A vector of key-value pairs (`OutputVec`) where keys are `K3*` and values are `V3*`.

### **Running the Sample**
Run the executable generated by the Makefile:
```bash
./SampleClient
```
This processes a sample input and outputs character frequencies.

---

## **Implementing Custom MapReduce Jobs**

1. **Define Key and Value Classes**:
    - Create custom classes for `K1`, `V1`, `K2`, `V2`, `K3`, and `V3` by inheriting from their respective base classes.

2. **Implement the `MapReduceClient`**:
    - Define the `map` and `reduce` methods in your custom client class.
    - Example:
      ```cpp
      class MyClient : public MapReduceClient {
          void map(const K1* key, const V1* value, void* context) const override {
              // Custom map logic
          }
          void reduce(const IntermediateVec* pairs, void* context) const override {
              // Custom reduce logic
          }
      };
      ```

3. **Run the Framework**:
    - Use the `startMapReduceJob` function to start the job:
      ```cpp
      JobHandle job = startMapReduceJob(myClient, inputVec, outputVec, numThreads);
      waitForJob(job);
      closeJobHandle(job);
      ```

---

## **Key Functions**

### **Framework Functions**
| Function                | Description                                                                                           |
|-------------------------|-------------------------------------------------------------------------------------------------------|
| `startMapReduceJob`     | Starts the MapReduce job with the given client, input, output, and number of threads.                 |
| `waitForJob`            | Blocks until all threads in the job complete.                                                        |
| `getJobState`           | Retrieves the current phase and progress percentage of the job.                                      |
| `closeJobHandle`        | Cleans up resources and threads after the job is complete.                                           |

### **Emit Functions**
| Function  | Description                                                                                   |
|-----------|-----------------------------------------------------------------------------------------------|
| `emit2`   | Emits intermediate key-value pairs during the `map` phase.                                   |
| `emit3`   | Emits final key-value pairs during the `reduce` phase.                                       |

---

## **Example Output**

Sample execution of the provided `SampleClient.cpp`:
```
stage 1, 33.33%
stage 2, 100.00%
stage 3, 50.00%
stage 3, 100.00%
Done!
The character 'a' appeared 5 times
The character 'b' appeared 3 times
The character 'c' appeared 4 times
...
```

---

## **Acknowledgments**
This framework was developed as part of the **67808 Operating Systems** course at the Hebrew University. It was designed and tested in a **Linux environment**, leveraging the POSIX threading library. Special thanks to the course instructors for their guidance and support.

---
